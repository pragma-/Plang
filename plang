#!/usr/bin/env perl

use warnings;
use strict;

# allow loading .pm modules from the current directory
use lib '.';

use Data::Dumper;

use Plang::Plang;

# example of setting up a simple straight-forward Plang interpreter
sub plang {
    my ($text) = @_;

    # create Plang object
    my $plang = Plang::Plang->new;

    if (defined $text) {
        # if a string argument was provided, interpret the string
        return $plang->interpret_string($text);
    } else {
        # otherwise interpret the standard input stream
        return $plang->interpret_stream(*STDIN);
    }
}

# and that's all there is to it!

# example using slightly more control over the lex/parse/interpret stages
my $debug = $ENV{DEBUG} // 0;

# Grammar rule: DumpToken --> *
sub DumpToken {
    my ($parser) = @_;
    return $parser->next_token;
}

sub plang_dbg {
    my $plang = Plang::Plang->new(embedded => 0, debug => $debug);

    # if --dumptokens was specified on command-line, use the DumpToken rule
    # otherwise use the Program rule
    my $dumptokens = 0;
    if (grep { $_ eq '--dumptokens' } @ARGV) {
        # generates all the tokens as a flat list
        $plang->{parser}->clear_rules;
        $plang->{parser}->add_rule(\&DumpToken);
        $dumptokens = 1;
    }

    # iterate over lines of standard input
    my $input_iter = sub { <STDIN> };

    # iterate over tokens
    my $token_iter = $plang->{lexer}->tokens($input_iter);

    # parse the input into $result
    my $result = $plang->{parser}->parse($token_iter);

    # were there any parse errors? print them and exit
    $plang->handle_parse_errors;

    # dump the $result data structure
    if ($dumptokens or $debug >= 2) {
        $Data::Dumper::Terse = 1;
        $Data::Dumper::Indent = 1;
        $Data::Dumper::Useqq = 1;

        print Dumper ($result), "\n";
    }

    # unless --dumptokens was specified on the command-line, interpret the AST
    # and exit with the return value.
    return 0 if $dumptokens;
    return $plang->{interpreter}->run($result);
}

# our return value/exit code
my $ret;

# two ways to run the simple example:
#
# $ret = plang 'fn square(x) { x * x } square(7)';  # interpret a string
#
# or
#
# $ret = plang;  # interpet stdin; e.g. `$ ./plang <<< '2 * 3'` or `$ ./plang < program.p`

# but for this program, we'll run the dbg example:
$ret = plang_dbg;

no warnings;
exit $ret;
