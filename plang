#!/usr/bin/env perl

# example Plang interpreter start-up script

use warnings;
use strict;

# allow loading .pm modules from the current directory
use lib '.';

use Data::Dumper;
use Plang::Interpreter;

print "This script reads from standard input.\n" and exit if @ARGV;

# example of setting up a simple straight-forward Plang interpreter
sub plang {
    my ($text) = @_;

    # create Plang object
    my $plang = Plang::Interpreter->new(debug => $ENV{DEBUG});

    if (defined $text) {
        # if a string argument was provided, interpret the string
        return $plang->interpret_string($text);
    } else {
        # otherwise interpret the standard input stream
        return $plang->interpret_stream(*STDIN);
    }
}

# and that's all there is to it!

# example using more control over the lex/parse/validate/interpret stages
my $debug = $ENV{DEBUG} // 0;
my @debug_tags = split /,/, $debug;

# Grammar rule: DumpToken ::= *
sub DumpToken {
    my ($parser) = @_;
    return $parser->next_token;
}

sub plang_dbg {
    my $plang = Plang::Interpreter->new(embedded => 0, debug => $debug);

    # if --dumptokens was specified on command-line, use the DumpToken rule
    # otherwise use the Program rule
    my $dumptokens = 0;
    if (grep { $_ eq '--dumptokens' } @ARGV) {
        # generates all the tokens as a flat list
        $plang->{parser}->clear_rules;
        $plang->{parser}->add_rule(\&DumpToken);
        $dumptokens = 1;
    }

    # iterate over lines of standard input
    my $input_iter = sub { <STDIN> };

    # iterate over tokens
    my $token_iter = $plang->{lexer}->tokens($input_iter);

    # parse the input into $result
    my $result = $plang->{parser}->parse($token_iter);

    # were there any parse errors? print them and exit
    $plang->handle_parse_errors;

    # dump the $result data structure
    if ($dumptokens or grep { $_ eq 'AST' } @debug_tags) {
        $Data::Dumper::Terse = 1;
        $Data::Dumper::Indent = 1;
        $Data::Dumper::Useqq = 1;

        print Dumper ($result), "\n";
    }

    # unless --dumptokens was specified on the command-line, interpret the AST
    # and exit with the return value.
    return 0 if $dumptokens;

    print "VALIDATOR\n";
    # validate the program
    my $errors = $plang->{validator}->validate($result);

    if ($errors) {
        print STDERR $errors->[1];
        exit 1;
    }

    print "INTERPRETER\n";

    # interpret the program
    return $plang->{interpreter}->run($result);
}

# our return value/exit code
my $ret;

# two ways to run the simple example:
#
# $ret = plang 'fn square(x) x * x; square(7)';  # interpret a string
#
# or
#
# $ret = plang;  # interpet stdin; e.g. `$ ./plang <<< '2 * 3'` or `$ ./plang < program.p`

# but for this program, we'll run the dbg example, unless PLANG_EMBED is defined:
if ($ENV{PLANG_EMBED}) {
    $ret = plang;
} else {
    $ret = plang_dbg;
}

no warnings;
exit $ret;
